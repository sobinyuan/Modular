import com.android.build.gradle.AppPlugin
import com.android.build.gradle.LibraryPlugin

if (isThreeAsApp.toBoolean()) {
    apply plugin: 'com.android.application'
} else {
    apply plugin: 'com.android.library'
}

ext {
    bintrayRepo = 'maven'
    bintrayName = 'modularthree'

    publishedGroupId = 'com.sobin.modularthree'
    libraryName = 'AndroidModular'
    artifact = 'modularthree'

    libraryDescription = 'Android Modular'

    siteUrl = 'https://github.com/sobinyuan/AndroidModular'
    gitUrl = 'https://github.com/sobinyuan/AndroidModular.git'

    libraryVersion = '1.0.3'

    developerId = 'isncteam'
    developerName = 'SobinYuan'
    developerEmail = 'yuanshuobin@gmail.com'

    licenseName = 'The Apache Software License, Version 2.0'
    licenseUrl = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
    allLicenses = ["Apache-2.0"]
}



android {
    compileSdkVersion 24
    buildToolsVersion "24.0.2"

    defaultConfig {
//        applicationId "com.sobin.modularthree"
        minSdkVersion 19
        targetSdkVersion 24
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"

    }
    buildTypes {
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }

    sourceSets {
        main {
            if (isThreeAsApp.toBoolean()) {
                manifest.srcFile 'src/main/debug/AndroidManifest.xml'
            } else {
                manifest.srcFile 'src/main/release/AndroidManifest.xml'
                java {
                    exclude 'debug/**'
                }
            }
        }
    }
}
if (!isThreeAsApp.toBoolean()) {
    //合成aar脚本
    apply from: 'fat-aar.gradle'
}


dependencies {
    compile fileTree(include: ['*.jar'], dir: 'libs')
    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
        exclude group: 'com.android.support', module: 'support-annotations'
    })
    compile 'com.android.support:appcompat-v7:24.0.0'
    testCompile 'junit:junit:4.12'
    if (!isThreeAsApp.toBoolean()) {
        //embedded 标记需要合并的module

        embedded project(':modularone')
        embedded project(':modulartwo')

    } else {
        compile project(':modularone')
        compile project(':modulartwo')
    }

}

if (!isThreeAsApp.toBoolean()) {
    //upload to bintray
    apply from: 'install.gradle'
    apply from: 'bintray.gradle'

    //build Jar
    task buildJar(type: Jar) {

        appendix = "demo"
        baseName = "androidJar"
        version = "1.7.0"
        classifier = "release"

        //后缀名
        extension = "jar"
        //最终的 Jar 包名，如果没设置，默认为 [baseName]-[appendix]-[version]-[classifier].[extension]
        archiveName = "SDK.jar"

        //需打包的资源所在的路径集
        def srcClassDir = [project.buildDir.absolutePath + "/intermediates/classes/release"];
        //初始化资源路径集
        from srcClassDir

        //去除路径集下部分的资源
//    exclude '**/BuildConfig.class'
//    exclude '**/R.class'
//    exclude '**/R$*.class'

    }

    def androidSDKDir = plugins.getPlugin('com.android.library').sdkHandler.getSdkFolder()
    def androidJarDir = androidSDKDir.toString() + '/platforms/' + "${android.compileSdkVersion}" + '/android.jar'

//proguard Jar
    task proguardJar(dependsOn: ['buildJar'], type: proguard.gradle.ProGuardTask) {
        //Android 默认的 graoguard 文件
        configuration android.getDefaultProguardFile('proguard-android.txt')
        //会根据该文件对 Jar 进行混淆，注意：需要在 manifest 注册的组件也要加入该文件中
        configuration 'proguard-rules.pro'

        String inJar = buildJar.archivePath.getAbsolutePath()
        //输入 jar
        injars inJar
        //输出 jar
        outjars inJar.substring(0, inJar.lastIndexOf('/')) + "/SuperID${buildJar.archiveName}"
        libraryjars(androidJarDir)

        //设置不删除未引用的资源(类，方法等)
        dontshrink

        Plugin appPlugin = getPlugins().hasPlugin(AppPlugin) ?
                getPlugins().findPlugin(AppPlugin) :
                getPlugins().findPlugin(LibraryPlugin)
        if (appPlugin != null) {
            List<String> runtimeJarList
            if (appPlugin.getMetaClass().getMetaMethod("getRuntimeJarList")) {
                runtimeJarList = appPlugin.getRuntimeJarList()
            } else if (android.getMetaClass().getMetaMethod("getBootClasspath")) {
                runtimeJarList = android.getBootClasspath()
            } else {
                runtimeJarList = appPlugin.getBootClasspath()
            }

            for (String runtimeJar : runtimeJarList) {
                //给 proguard 添加 runtime
                libraryjars(runtimeJar)
            }
        }
    }
}




